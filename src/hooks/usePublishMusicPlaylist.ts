import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useCurrentUser } from '@/hooks/useCurrentUser';
import { useNostrPublish } from '@/hooks/useNostrPublish';
import { useUploadFile } from '@/hooks/useUploadFile';
import type { MusicPlaylistFormData, MusicPlaylistData } from '@/types/music';
import { isArtist } from '@/lib/musicConfig';
import { musicPlaylistPublisher } from '@/lib/musicPlaylistPublisher';

/**
 * Process form data and upload files to create MusicPlaylistData
 */
async function processPlaylistFormData(
  formData: MusicPlaylistFormData,
  uploadFile: (file: File) => Promise<Array<string[]>>
): Promise<MusicPlaylistData> {
  let imageUrl = formData.imageUrl;

  // Upload image file if provided
  if (formData.imageFile) {
    try {
      const imageTags = await uploadFile(formData.imageFile);
      const imageTag = imageTags.find((tag: string[]) => tag[0] === 'url') || imageTags[0];
      imageUrl = imageTag[1];
    } catch (error) {
      throw new Error(`Failed to upload playlist image: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Create MusicPlaylistData from form data
  const playlistData: MusicPlaylistData = {
    identifier: '', // Will be generated by publisher
    title: formData.title,
    tracks: formData.trackReferences || [],
    description: formData.description,
    imageUrl,
    categories: formData.categories
  };

  return playlistData;
}

/**
 * Hook for publishing music playlists (artist only)
 */
export function usePublishMusicPlaylist() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const { mutateAsync: uploadFile } = useUploadFile();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (formData: MusicPlaylistFormData): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to create playlists');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can create playlists');
      }

      // Process form data and upload files
      const playlistData = await processPlaylistFormData(formData, uploadFile);

      // Create the music playlist event
      const eventData = musicPlaylistPublisher.createPlaylistEvent(playlistData);

      // Publish the event
      const event = await createEvent(eventData);

      // Invalidate related queries to refresh the UI
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['podcast-stats'] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to publish music playlist:', error);
    }
  });
}

/**
 * Hook for updating existing music playlists
 */
export function useUpdateMusicPlaylist() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const { mutateAsync: uploadFile } = useUploadFile();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      playlistIdentifier,
      formData
    }: {
      playlistIdentifier: string;
      formData: MusicPlaylistFormData;
    }): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to update playlists');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can update playlists');
      }

      // Process form data and upload files
      const playlistData = await processPlaylistFormData(formData, uploadFile);

      // Create the update event with the original identifier
      const eventData = musicPlaylistPublisher.createUpdateEvent(playlistIdentifier, playlistData);

      // Publish the update event
      const event = await createEvent(eventData);

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlist', playlistIdentifier] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to update music playlist:', error);
    }
  });
}

/**
 * Hook for adding tracks to an existing playlist
 */
export function useAddTracksToPlaylist() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      currentPlaylist,
      newTracks,
      position
    }: {
      currentPlaylist: MusicPlaylistData;
      newTracks: Array<{ pubkey: string; identifier: string; title?: string; artist?: string }>;
      position?: number;
    }): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to modify playlists');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can modify playlists');
      }

      // Convert new tracks to TrackReference format
      const trackReferences = newTracks.map(track => ({
        kind: 36787 as const,
        pubkey: track.pubkey,
        identifier: track.identifier,
        title: track.title,
        artist: track.artist
      }));

      // Add tracks to playlist
      const updatedPlaylist = musicPlaylistPublisher.addTracksToPlaylist(
        currentPlaylist,
        trackReferences,
        position
      );

      // Create update event
      const eventData = musicPlaylistPublisher.createUpdateEvent(
        currentPlaylist.identifier,
        updatedPlaylist
      );

      // Publish the update event
      const event = await createEvent(eventData);

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlist', currentPlaylist.identifier] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to add tracks to playlist:', error);
    }
  });
}

/**
 * Hook for removing tracks from a playlist
 */
export function useRemoveTracksFromPlaylist() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      currentPlaylist,
      trackIndices
    }: {
      currentPlaylist: MusicPlaylistData;
      trackIndices: number[];
    }): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to modify playlists');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can modify playlists');
      }

      // Remove tracks from playlist
      const updatedPlaylist = musicPlaylistPublisher.removeTracksFromPlaylist(
        currentPlaylist,
        trackIndices
      );

      // Create update event
      const eventData = musicPlaylistPublisher.createUpdateEvent(
        currentPlaylist.identifier,
        updatedPlaylist
      );

      // Publish the update event
      const event = await createEvent(eventData);

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlist', currentPlaylist.identifier] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to remove tracks from playlist:', error);
    }
  });
}

/**
 * Hook for reordering tracks in a playlist
 */
export function useReorderPlaylistTracks() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      currentPlaylist,
      fromIndex,
      toIndex
    }: {
      currentPlaylist: MusicPlaylistData;
      fromIndex: number;
      toIndex: number;
    }): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to modify playlists');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can modify playlists');
      }

      // Reorder tracks in playlist
      const updatedPlaylist = musicPlaylistPublisher.reorderPlaylistTracks(
        currentPlaylist,
        fromIndex,
        toIndex
      );

      // Create update event
      const eventData = musicPlaylistPublisher.createUpdateEvent(
        currentPlaylist.identifier,
        updatedPlaylist
      );

      // Publish the update event
      const event = await createEvent(eventData);

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlist', currentPlaylist.identifier] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to reorder playlist tracks:', error);
    }
  });
}

/**
 * Hook for deleting music playlists (creates deletion event)
 */
export function useDeleteMusicPlaylist() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (playlistEventId: string): Promise<string> => {
      if (!user) {
        throw new Error('You must be logged in to delete playlists');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can delete playlists');
      }

      // Create a deletion event (NIP-09)
      const event = await createEvent({
        kind: 5, // Deletion event
        content: 'Deleted music playlist',
        tags: [
          ['e', playlistEventId]
        ]
      });

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlist', playlistEventId] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to delete music playlist:', error);
    }
  });
}