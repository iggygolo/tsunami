import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useCurrentUser } from '@/hooks/useCurrentUser';
import { useNostrPublish } from '@/hooks/useNostrPublish';
import { useUploadFile } from '@/hooks/useUploadFile';
import type { MusicTrackFormData, MusicTrackData } from '@/types/music';
import { isArtist } from '@/lib/musicConfig';
import { musicTrackPublisher } from '@/lib/musicTrackPublisher';

// Helper function to infer audio type from URL
function inferAudioType(urlString: string, fileType?: string): string {
  if (fileType && fileType.startsWith('audio/')) {
    return fileType;
  }

  try {
    const url = new URL(urlString);
    const pathname = url.pathname.toLowerCase();
    if (pathname.endsWith('.mp3')) {
      return 'audio/mpeg';
    } else if (pathname.endsWith('.wav')) {
      return 'audio/wav';
    } else if (pathname.endsWith('.m4a')) {
      return 'audio/mp4';
    } else if (pathname.endsWith('.ogg')) {
      return 'audio/ogg';
    } else if (pathname.endsWith('.flac')) {
      return 'audio/flac';
    }
  } catch {
    // Invalid URL, continue with default
  }
  
  return 'audio/mpeg'; // Default fallback
}

/**
 * Process form data and upload files to create MusicTrackData
 */
async function processTrackFormData(
  formData: MusicTrackFormData,
  uploadFile: (file: File) => Promise<Array<string[]>>
): Promise<MusicTrackData> {
  let audioUrl = formData.audioUrl;
  let imageUrl = formData.imageUrl;
  let videoUrl = formData.videoUrl;

  // Upload audio file if provided
  if (formData.audioFile) {
    try {
      const audioTags = await uploadFile(formData.audioFile);
      // audioTags is an array of NIP-94 compatible tags
      const audioTag = audioTags.find((tag: string[]) => tag[0] === 'url') || audioTags[0];
      audioUrl = audioTag[1]; // Get the URL from the tag
    } catch (error) {
      throw new Error(`Failed to upload audio file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Upload image file if provided
  if (formData.imageFile) {
    try {
      const imageTags = await uploadFile(formData.imageFile);
      const imageTag = imageTags.find((tag: string[]) => tag[0] === 'url') || imageTags[0];
      imageUrl = imageTag[1];
    } catch (error) {
      throw new Error(`Failed to upload image file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Upload video file if provided
  if (formData.videoFile) {
    try {
      const videoTags = await uploadFile(formData.videoFile);
      const videoTag = videoTags.find((tag: string[]) => tag[0] === 'url') || videoTags[0];
      videoUrl = videoTag[1];
    } catch (error) {
      throw new Error(`Failed to upload video file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  if (!audioUrl) {
    throw new Error('Audio URL or file is required');
  }

  // Infer audio format from URL if not provided
  const format = formData.format || inferAudioType(audioUrl, formData.audioType);

  // Create MusicTrackData from form data
  const trackData: MusicTrackData = {
    identifier: '', // Will be generated by publisher
    title: formData.title,
    artist: formData.artist,
    audioUrl,
    description: formData.description,
    album: formData.album,
    trackNumber: formData.trackNumber,
    releaseDate: formData.releaseDate,
    duration: formData.duration,
    format,
    bitrate: formData.bitrate,
    sampleRate: formData.sampleRate,
    imageUrl,
    videoUrl,
    lyrics: formData.lyrics,
    credits: formData.credits,
    language: formData.language,
    explicit: formData.explicit || false,
    genres: formData.genres,
    zapSplits: formData.zapSplits
  };

  return trackData;
}

/**
 * Hook for publishing individual music tracks (artist only)
 */
export function usePublishMusicTrack() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const { mutateAsync: uploadFile } = useUploadFile();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (formData: MusicTrackFormData): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to publish music tracks');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can publish tracks');
      }

      // Process form data and upload files
      const trackData = await processTrackFormData(formData, uploadFile);

      // Create the music track event
      const eventData = musicTrackPublisher.createTrackEvent(trackData);

      // Publish the event
      const event = await createEvent(eventData);

      // Invalidate related queries to refresh the UI
      await queryClient.invalidateQueries({ queryKey: ['music-tracks'] });
      await queryClient.invalidateQueries({ queryKey: ['releases'] }); // For compatibility
      await queryClient.invalidateQueries({ queryKey: ['music-stats'] });
      await queryClient.invalidateQueries({ queryKey: ['rss-feed-generator'] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to publish music track:', error);
    }
  });
}

/**
 * Hook for updating existing music tracks
 */
export function useUpdateMusicTrack() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const { mutateAsync: uploadFile } = useUploadFile();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      trackIdentifier,
      formData
    }: {
      trackIdentifier: string;
      formData: MusicTrackFormData;
    }): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to update music tracks');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can update tracks');
      }

      // Process form data and upload files
      const trackData = await processTrackFormData(formData, uploadFile);

      // Create the update event with the original identifier
      const eventData = musicTrackPublisher.createUpdateEvent(trackIdentifier, trackData);

      // Publish the update event
      const event = await createEvent(eventData);

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['music-tracks'] });
      await queryClient.invalidateQueries({ queryKey: ['music-track', trackIdentifier] });
      await queryClient.invalidateQueries({ queryKey: ['releases'] }); // For compatibility
      await queryClient.invalidateQueries({ queryKey: ['music-stats'] });
      await queryClient.invalidateQueries({ queryKey: ['rss-feed-generator'] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to update music track:', error);
    }
  });
}

/**
 * Hook for deleting music tracks (creates deletion event)
 */
export function useDeleteMusicTrack() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (trackEventId: string): Promise<string> => {
      if (!user) {
        throw new Error('You must be logged in to delete music tracks');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can delete tracks');
      }

      // Create a deletion event (NIP-09)
      const event = await createEvent({
        kind: 5, // Deletion event
        content: 'Deleted music track',
        tags: [
          ['e', trackEventId]
        ]
      });

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['music-tracks'] });
      await queryClient.invalidateQueries({ queryKey: ['music-track', trackEventId] });
      await queryClient.invalidateQueries({ queryKey: ['releases'] }); // For compatibility
      await queryClient.invalidateQueries({ queryKey: ['music-stats'] });
      await queryClient.invalidateQueries({ queryKey: ['rss-feed-generator'] });

      return event.id;
    },

    onError: (error) => {
      console.error('Failed to delete music track:', error);
    }
  });
}