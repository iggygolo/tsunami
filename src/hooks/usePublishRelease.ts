import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useCurrentUser } from '@/hooks/useCurrentUser';
import { useNostrPublish } from '@/hooks/useNostrPublish';
import { useUploadFile } from '@/hooks/useUploadFile';
import type { ReleaseFormData, TrackFormData, MusicTrackData, MusicPlaylistData, TrackReference } from '@/types/music';
import { MUSIC_KINDS, MUSIC_CONFIG, isArtist } from '@/lib/musicConfig';
import { musicTrackPublisher } from '@/lib/musicTrackPublisher';
import { musicPlaylistPublisher } from '@/lib/musicPlaylistPublisher';
import { audioTypeToFormat } from '@/lib/audioUtils';

// Helper function to infer audio type from URL
function inferAudioType(urlString: string, fileType?: string): string {
  if (fileType && fileType.startsWith('audio/')) {
    return fileType;
  }

  try {
    const url = new URL(urlString);
    const pathname = url.pathname.toLowerCase();
    if (pathname.endsWith('.mp3')) {
      return 'audio/mpeg';
    } else if (pathname.endsWith('.wav')) {
      return 'audio/wav';
    } else if (pathname.endsWith('.m4a')) {
      return 'audio/mp4';
    } else if (pathname.endsWith('.ogg')) {
      return 'audio/ogg';
    } else if (pathname.endsWith('.flac')) {
      return 'audio/flac';
    }
  } catch {
    // Invalid URL, continue with default
  }
  
  return 'audio/mpeg'; // Default fallback
}

/**
 * Convert TrackFormData to MusicTrackData for individual track publishing
 */
async function convertTrackFormDataToMusicTrackData(
  track: TrackFormData,
  uploadFile: (file: File) => Promise<Array<string[]>>,
  releaseData: ReleaseFormData,
  trackIndex: number,
  artistPubkey: string
): Promise<MusicTrackData> {
  let audioUrl = track.audioUrl;
  let audioType = track.audioType;

  if (track.audioFile) {
    try {
      const audioTags = await uploadFile(track.audioFile);
      // audioTags is an array of NIP-94 compatible tags
      const audioTag = audioTags.find((tag: string[]) => tag[0] === 'url') || audioTags[0];
      audioUrl = audioTag[1]; // Get the URL from the tag
      audioType = track.audioFile.type;
    } catch (error) {
      throw new Error(`Failed to upload audio file for track "${track.title}": ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  if (!audioUrl) {
    throw new Error(`Audio URL or file is required for track "${track.title}"`);
  }

  // Infer type from URL if not provided
  if (audioUrl && !audioType) {
    audioType = inferAudioType(audioUrl);
  }

  // Convert format from audioType
  const format = audioTypeToFormat(audioType || 'audio/mpeg');

  // Create MusicTrackData from TrackFormData and ReleaseFormData
  const trackData: MusicTrackData = {
    identifier: '', // Will be generated by publisher
    title: track.title,
    artist: MUSIC_CONFIG.music.artistName, // Use actual artist name from config
    audioUrl,
    album: releaseData.title, // Use release title as album
    trackNumber: trackIndex + 1, // 1-based track numbering
    duration: track.duration,
    format,
    imageUrl: undefined, // Will be set from release image
    language: track.language || undefined,
    explicit: track.explicit || false,
    genres: releaseData.tags.length > 0 ? releaseData.tags : undefined,
    artistPubkey: artistPubkey,
  };

  return trackData;
}

/**
 * Hook for publishing podcast releases (artist only)
 * Now creates individual track events (kind 36787) and a playlist event (kind 34139)
 */
export function usePublishRelease() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const { mutateAsync: uploadFile } = useUploadFile();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (releaseData: ReleaseFormData): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to publish releases');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can publish releases');
      }

      // Validate that we have at least one track
      if (!releaseData.tracks || releaseData.tracks.length === 0) {
        throw new Error('At least one track is required');
      }

      // Upload release image if provided
      let releaseImageUrl = releaseData.imageUrl;
      if (releaseData.imageFile) {
        try {
          const imageTags = await uploadFile(releaseData.imageFile);
          releaseImageUrl = imageTags[0][1]; // First tag contains the URL
        } catch (error) {
          throw new Error(`Failed to upload release image: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      }

      // Step 1: Create individual track events (kind 36787)
      const trackReferences: TrackReference[] = [];
      const trackEventIds: string[] = [];

      for (let i = 0; i < releaseData.tracks.length; i++) {
        const track = releaseData.tracks[i];
        
        // Convert track form data to music track data
        const trackData = await convertTrackFormDataToMusicTrackData(
          track, 
          uploadFile, 
          releaseData, 
          i, 
          user.pubkey
        );

        // Set release image as track image if available
        if (releaseImageUrl) {
          trackData.imageUrl = releaseImageUrl;
        }

        // Create track event
        const trackEventData = musicTrackPublisher.createTrackEvent(trackData);
        const trackEvent = await createEvent(trackEventData);

        // Store track reference for playlist
        trackReferences.push({
          kind: MUSIC_KINDS.MUSIC_TRACK,
          pubkey: user.pubkey,
          identifier: trackData.identifier,
          title: trackData.title,
          artist: trackData.artist,
        });

        trackEventIds.push(trackEvent.id);
      }

      // Step 2: Create playlist/release event (kind 34139)
      const playlistData: MusicPlaylistData = {
        identifier: '', // Will be generated by publisher
        title: releaseData.title,
        tracks: trackReferences,
        description: releaseData.description,
        imageUrl: releaseImageUrl,
        categories: releaseData.tags.length > 0 ? releaseData.tags : undefined,
        isPublic: true,
        authorPubkey: user.pubkey,
      };

      // Create playlist event
      const playlistEventData = musicPlaylistPublisher.createPlaylistEvent(playlistData);
      const playlistEvent = await createEvent(playlistEventData);

      // Invalidate related queries to refresh the UI
      await queryClient.invalidateQueries({ queryKey: ['releases'] });
      await queryClient.invalidateQueries({ queryKey: ['music-tracks'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['podcast-stats'] });
      await queryClient.invalidateQueries({ queryKey: ['rss-feed-generator'] });

      // Return the playlist event ID as the main release ID
      return playlistEvent.id;
    },

    onError: (error) => {
      console.error('Failed to publish release:', error);
    }
  });
}

/**
 * Hook for updating/editing existing releases
 * Now updates both individual track events (kind 36787) and playlist event (kind 34139)
 */
export function useUpdateRelease() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const { mutateAsync: uploadFile } = useUploadFile();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      releaseId,
      releaseIdentifier,
      releaseData
    }: {
      releaseId: string;
      releaseIdentifier: string;
      releaseData: ReleaseFormData;
    }): Promise<string> => {
      // Verify user is logged in and is the artist
      if (!user) {
        throw new Error('You must be logged in to update releases');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can update releases');
      }

      // Validate that we have at least one track
      if (!releaseData.tracks || releaseData.tracks.length === 0) {
        throw new Error('At least one track is required');
      }

      // Upload release image if provided
      let releaseImageUrl = releaseData.imageUrl;
      if (releaseData.imageFile) {
        try {
          const imageTags = await uploadFile(releaseData.imageFile);
          releaseImageUrl = imageTags[0][1];
        } catch (error) {
          throw new Error(`Failed to upload release image: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      }

      // Step 1: Create/update individual track events (kind 36787)
      const trackReferences: TrackReference[] = [];
      const trackEventIds: string[] = [];

      for (let i = 0; i < releaseData.tracks.length; i++) {
        const track = releaseData.tracks[i];
        
        // Convert track form data to music track data
        const trackData = await convertTrackFormDataToMusicTrackData(
          track, 
          uploadFile, 
          releaseData, 
          i, 
          user.pubkey
        );

        // Set release image as track image if available
        if (releaseImageUrl) {
          trackData.imageUrl = releaseImageUrl;
        }

        // Create updated track event
        const trackEventData = musicTrackPublisher.createTrackEvent(trackData);
        const trackEvent = await createEvent(trackEventData);

        // Store track reference for playlist
        trackReferences.push({
          kind: MUSIC_KINDS.MUSIC_TRACK,
          pubkey: user.pubkey,
          identifier: trackData.identifier,
          title: trackData.title,
          artist: trackData.artist,
        });

        trackEventIds.push(trackEvent.id);
      }

      // Step 2: Update playlist/release event (kind 34139)
      const playlistData: MusicPlaylistData = {
        identifier: releaseIdentifier, // Preserve original identifier
        title: releaseData.title,
        tracks: trackReferences,
        description: releaseData.description,
        imageUrl: releaseImageUrl,
        categories: releaseData.tags.length > 0 ? releaseData.tags : undefined,
        isPublic: true,
        authorPubkey: user.pubkey,
      };

      // Create updated playlist event
      const playlistEventData = musicPlaylistPublisher.createUpdateEvent(releaseIdentifier, playlistData);
      const playlistEvent = await createEvent(playlistEventData);

      // Invalidate related queries to refresh the UI
      await queryClient.invalidateQueries({ queryKey: ['releases'] });
      await queryClient.invalidateQueries({ queryKey: ['music-tracks'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['podcast-release', releaseId] });
      await queryClient.invalidateQueries({ queryKey: ['podcast-stats'] });
      await queryClient.invalidateQueries({ queryKey: ['rss-feed-generator'] });

      return playlistEvent.id;
    },
    onSuccess: (data) => {
      console.log('release update successful:', data);
    },
    onError: (error) => {
      console.error('release update failed:', error);
    },
    onSettled: (data, error) => {
      console.log('release update settled:', { data, error });
    }
  });
}

/**
 * Hook for deleting releases (creates deletion events for both tracks and playlist)
 */
export function useDeleteRelease() {
  const { user } = useCurrentUser();
  const { mutateAsync: createEvent } = useNostrPublish();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      playlistId,
      trackIds
    }: {
      playlistId: string;
      trackIds?: string[];
    }): Promise<string[]> => {
      if (!user) {
        throw new Error('You must be logged in to delete releases');
      }

      if (!isArtist(user.pubkey)) {
        throw new Error('Only the music artist can delete releases');
      }

      const deletionEventIds: string[] = [];

      // Delete individual track events if provided
      if (trackIds && trackIds.length > 0) {
        for (const trackId of trackIds) {
          const trackDeletionEvent = await createEvent({
            kind: 5, // Deletion event
            content: 'Deleted track',
            tags: [
              ['e', trackId]
            ]
          });
          deletionEventIds.push(trackDeletionEvent.id);
        }
      }

      // Delete the playlist event
      const playlistDeletionEvent = await createEvent({
        kind: 5, // Deletion event
        content: 'Deleted release/playlist',
        tags: [
          ['e', playlistId]
        ]
      });
      deletionEventIds.push(playlistDeletionEvent.id);

      // Invalidate queries
      await queryClient.invalidateQueries({ queryKey: ['releases'] });
      await queryClient.invalidateQueries({ queryKey: ['music-tracks'] });
      await queryClient.invalidateQueries({ queryKey: ['music-playlists'] });
      await queryClient.invalidateQueries({ queryKey: ['podcast-release', playlistId] });
      await queryClient.invalidateQueries({ queryKey: ['podcast-stats'] });
      await queryClient.invalidateQueries({ queryKey: ['rss-feed-generator'] });

      return deletionEventIds;
    }
  });
}
